<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAC Racing</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #info {
            text-align: center;
            color: white;
            font-weight: 900;
            font-size: 1.2rem;
            text-shadow: 2px 2px 0px #000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #speedometer {
            text-align: right;
            color: #ffeb3b;
            font-size: 3rem;
            font-weight: 900;
            font-style: italic;
            text-shadow: 3px 3px 0px #d32f2f;
        }
        #menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }
        .stat-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
            font-size: 1.2rem;
        }
        button.menu-btn {
            padding: 5px 15px;
            font-size: 1.2rem;
            cursor: pointer;
            background: #ffeb3b;
            border: none;
            border-radius: 5px;
            font-weight: bold;
        }
        button.start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 2rem;
            background: #d50000;
            color: white;
            border: 4px solid white;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: 900;
        }
        button.start-btn:hover { background: #ff1744; }
        #hud {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: white; font-weight: bold; font-size: 1.5rem; text-shadow: 2px 2px 0 #000;
            display: none;
        }
        #item-hud {
            position: absolute; top: 20px; left: 20px; text-align: left;
            color: #ffeb3b; font-weight: 900; font-size: 2rem; text-shadow: 3px 3px 0 #d50000;
            display: none;
        }
        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 10rem; color: #ffeb3b; font-weight: 900; text-shadow: 5px 5px 0 #d50000;
            display: none; pointer-events: none;
        }
        #results {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 20;
        }
        .result-row { font-size: 1.5rem; margin: 10px 0; }
        .result-title { font-size: 3rem; margin-bottom: 20px; color: #ffeb3b; text-shadow: 3px 3px 0 #d50000; }
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            display: none;
        }
        #mirror-border { display: none; }
        #wrong-way { display: none; position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); color: red; font-size: 5rem; font-weight: 900; text-shadow: 4px 4px 0 black; border: 5px solid white; padding: 20px; background: rgba(0,0,0,0.5); z-index: 100; }
        #cheat-console {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border: 2px solid white;
            z-index: 1000;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1 style="font-size: 4rem; margin-bottom: 20px; text-shadow: 4px 4px 0 #d50000; font-style: italic;">CAC RACING</h1>
        
        <div style="background: rgba(255,255,255,0.1); padding: 30px; border-radius: 15px; text-align: center;">
            <div class="stat-row">
                <label>Vehicle Color:</label>
                <input type="color" id="carColor" value="#d50000" style="width: 60px; height: 40px; border: none; cursor: pointer;">
            </div>
            
            <h2 style="border-bottom: 2px solid white; padding-bottom: 5px; margin-top: 20px;">UPGRADES (Credits: <span id="credits">5</span>)</h2>
            
            <div class="stat-row">
                <span style="width: 150px; text-align: left;">Top Speed</span>
                <button class="menu-btn" onclick="window.adjustStat('speed', -1)">-</button>
                <span id="speedVal" style="width: 30px;">0</span>
                <button class="menu-btn" onclick="window.adjustStat('speed', 1)">+</button>
            </div>
            <div class="stat-row">
                <span style="width: 150px; text-align: left;">Acceleration</span>
                <button class="menu-btn" onclick="window.adjustStat('accel', -1)">-</button>
                <span id="accelVal" style="width: 30px;">0</span>
                <button class="menu-btn" onclick="window.adjustStat('accel', 1)">+</button>
            </div>
            <div class="stat-row">
                <span style="width: 150px; text-align: left;">Handling</span>
                <button class="menu-btn" onclick="window.adjustStat('handling', -1)">-</button>
                <span id="handlingVal" style="width: 30px;">0</span>
                <button class="menu-btn" onclick="window.adjustStat('handling', 1)">+</button>
            </div>
            <div class="stat-row">
                <span style="width: 150px; text-align: left;">Jump Height</span>
                <button class="menu-btn" onclick="window.adjustStat('jump', -1)">-</button>
                <span id="jumpVal" style="width: 30px;">0</span>
                <button class="menu-btn" onclick="window.adjustStat('jump', 1)">+</button>
            </div>
        </div>

        <button class="start-btn" onclick="window.startGame()">START RACE</button>
    </div>

    <div id="hud">
        <div>POS: <span id="rank">1/4</span></div>
        <div>LAPS: <span id="lapCounter">1/3</span></div>
        <div>TIME: <span id="lapTimer">0.00</span></div>
        <div>BEST: <span id="bestLap">--:--</span></div>
        <div>SCORE: <span id="score">0</span></div>
    </div>

    <div id="item-hud">
        ITEM: <span id="storedItem">NONE</span> <span style="font-size: 1rem; color: white;">[E]</span>
    </div>

    <div id="countdown">3</div>

    <div id="results">
        <div class="result-title">RACE FINISHED!</div>
        <div class="result-row">Total Score: <span id="resScore">0</span></div>
        <div class="result-row">Best Lap: <span id="resBest">--:--</span></div>
        <div class="result-row">Top Speed: <span id="resTop">0</span> MPH</div>
        <div class="result-row">Avg Speed: <span id="resAvg">0</span> MPH</div>
        <button class="start-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <canvas id="minimap" width="200" height="200"></canvas>

    <div id="mirror-border" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 260px; height: 100px; border: 5px solid #333; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 5; pointer-events: none;"></div>
    <div id="wrong-way">WRONG WAY!</div>

    <div id="cheat-console">
        <div style="color: white; font-size: 1.5rem; font-weight: bold;">PAUSED</div>
        <div style="color: #ccc; margin-bottom: 10px;">Enter Cheat Code:</div>
        <input type="text" id="cheat-input" style="font-size: 1.5rem; padding: 5px; width: 300px;" placeholder="e.g. give invincibility">
    </div>

    <div id="ui-container" style="display: none;">
        <div id="info">WASD / Arrows to Drive &bull; R to Reset</div>
        <div id="speedometer">0 <span style="font-size: 1.5rem;">MPH</span></div>
    </div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 40, 150);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        const d = 100;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- Rear View Camera ---
        const rearCamera = new THREE.PerspectiveCamera(80, 2.6, 0.1, 500);
        rearCamera.position.set(0, 2.5, 2.5); // Behind/Above
        rearCamera.lookAt(0, 0, 15); // Look backwards and down at the track

        // --- Car Model ---
        function createCar(color = 0xd50000) {
            const carGroup = new THREE.Group();

            // Materials
            const paintMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.6 }); // Shiny Paint
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.0, metalness: 0.9 });
            const plasticMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });

            // Main Body
            const bodyGeo = new THREE.BoxGeometry(1.8, 0.6, 4.2);
            const body = new THREE.Mesh(bodyGeo, paintMat);
            body.position.y = 0.6;
            body.castShadow = true;
            carGroup.add(body);

            // Cabin (Top)
            const cabinGeo = new THREE.BoxGeometry(1.5, 0.5, 2.2);
            const cabin = new THREE.Mesh(cabinGeo, glassMat);
            cabin.position.set(0, 1.15, -0.3);
            cabin.castShadow = true;
            carGroup.add(cabin);

            // Spoiler
            const spoilerGeo = new THREE.BoxGeometry(1.8, 0.1, 0.6);
            const spoiler = new THREE.Mesh(spoilerGeo, paintMat);
            spoiler.position.set(0, 1.1, 1.8);
            spoiler.castShadow = true;
            carGroup.add(spoiler);
            
            const spoilerLegGeo = new THREE.BoxGeometry(0.1, 0.3, 0.2);
            const legL = new THREE.Mesh(spoilerLegGeo, paintMat);
            legL.position.set(0.6, 0.9, 1.8);
            carGroup.add(legL);
            const legR = new THREE.Mesh(spoilerLegGeo, paintMat);
            legR.position.set(-0.6, 0.9, 1.8);
            carGroup.add(legR);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.35, 24);
            wheelGeo.rotateZ(Math.PI / 2);
            const positions = [
                { x: 1, y: 0.4, z: 1.3 }, { x: -1, y: 0.4, z: 1.3 }, // Front
                { x: 1, y: 0.4, z: -1.3 }, { x: -1, y: 0.4, z: -1.3 } // Rear
            ];

            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, plasticMat);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);

                // Rims (Star shape texture simulated by cylinder for now)
                const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.36, 12), rimMat);
                rim.rotation.z = Math.PI / 2;
                rim.position.set(pos.x, pos.y, pos.z);
                carGroup.add(rim);
            });

            return carGroup;
        }

        const car = createCar();
        car.add(rearCamera); // Attach rear camera to player car
        scene.add(car);

        // --- Environment ---
        // Floor
        const floorGeo = new THREE.PlaneGeometry(2000, 2000);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Track Generation
        const trackScale = 4;
        const trackPoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -100),
            new THREE.Vector3(50, 0, -200),
            new THREE.Vector3(150, 0, -250),
            new THREE.Vector3(250, 0, -200),
            new THREE.Vector3(300, 0, -100),
            new THREE.Vector3(250, 0, 0),
            new THREE.Vector3(150, 0, 50),
            new THREE.Vector3(50, 0, 50),
            new THREE.Vector3(0, 0, 0)
        ].map(p => p.multiplyScalar(trackScale));
        const curve = new THREE.CatmullRomCurve3(trackPoints);
        curve.closed = true;

        const trackWidth = 30;
        const trackGeo = new THREE.TubeGeometry(curve, 400, trackWidth, 8, true); // 2 segments = flat ribbon if oriented right, but Tube is round.
        // Let's scale it to be flat
        trackGeo.scale(1, 0.01, 1); 
        
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });
        const track = new THREE.Mesh(trackGeo, trackMat);
        track.position.y = 0.1;
        track.receiveShadow = true;
        scene.add(track);

        // Checkerboard Texture for Start Line
        function createCheckerboard() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0,0,32,32);
            ctx.fillRect(32,32,32,32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(3, 1);
            return tex;
        }

        function createTextTexture(text, color, bgColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = color;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // Starting Line
        const startLineGeo = new THREE.PlaneGeometry(trackWidth, 8);
        const startLineMat = new THREE.MeshStandardMaterial({ map: createCheckerboard(), side: THREE.DoubleSide, polygonOffset: true, polygonOffsetFactor: -1 });
        const startLine = new THREE.Mesh(startLineGeo, startLineMat);
        startLine.position.copy(curve.getPointAt(0));
        startLine.position.y = 0.42; // Slightly above track surface (0.4)
        startLine.lookAt(curve.getPointAt(0).add(curve.getTangentAt(0))); // Face forward
        startLine.rotateX(-Math.PI / 2); // Lay flat
        scene.add(startLine);

        // Position Car on Track
        const startPos = curve.getPointAt(0);
        const startLook = curve.getPointAt(0.01);
        car.position.copy(startPos);
        car.position.y = 0.4;
        car.lookAt(2*startPos.x - startLook.x, 0.4, 2*startPos.z - startLook.z); // Look forward along track

        const trackPathPoints = curve.getSpacedPoints(2000);
        const trackLength = curve.getLength();

        const baseStats = { maxSpeed: 1.8, acceleration: 0.03, turnSpeed: 0.06, jumpStrength: 0.6 };

        // --- Environment (Trees & Cows) ---
        function createEnvironment() {
            const treeGeo = new THREE.ConeGeometry(5, 15, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
            const trunkGeo = new THREE.CylinderGeometry(1.5, 1.5, 5, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });

            const cowGeo = new THREE.BoxGeometry(4, 3, 6);
            const cowMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee }); 

            for(let i=0; i<150; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                const pos = new THREE.Vector3(x, 0, z);
                
                // Check distance to track to ensure trees are not on the road
                let onRoad = false;
                for(const p of trackPathPoints) {
                    if (pos.distanceToSquared(p) < (trackWidth/2 + 10)**2) { onRoad = true; break; }
                }
                if (onRoad) continue;

                if (Math.random() > 0.2) {
                    // Tree
                    const group = new THREE.Group();
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    const leaves = new THREE.Mesh(treeGeo, treeMat);
                    leaves.position.y = 10;
                    leaves.castShadow = true;
                    group.add(trunk);
                    group.add(leaves);
                    group.position.set(x, 0, z);
                    scene.add(group);
                } else {
                    // Cow (Blocky)
                    const cow = new THREE.Mesh(cowGeo, cowMat);
                    cow.position.set(x, 1.5, z);
                    cow.castShadow = true;
                    cow.lookAt(0, 1.5, 0);
                    scene.add(cow);
                }
            }
        }
        createEnvironment();

        // --- Game Elements (Obstacles, Ramps, Oil, Moving Cows) ---
        const obstacles = [];
        const ramps = [];
        const oilSlicks = [];
        const movingCows = [];
        const aiCars = [];
        const turbos = [];
        const mysteryBoxes = [];
        const buses = [];
        const coins = [];

        function createRailroadSign(pos) {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 5), new THREE.MeshStandardMaterial({color: 0x888888}));
            pole.position.y = 2.5;
            const cross1 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 0.1), new THREE.MeshStandardMaterial({color: 0xffffff}));
            cross1.position.set(0, 4, 0); cross1.rotation.z = Math.PI / 4;
            const cross2 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 0.1), new THREE.MeshStandardMaterial({color: 0xffffff}));
            cross2.position.set(0, 4, 0); cross2.rotation.z = -Math.PI / 4;
            const light1 = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0xff0000}));
            light1.position.set(-1.5, 3.5, 0.2);
            const light2 = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0xff0000}));
            light2.position.set(1.5, 3.5, 0.2);
            
            // Crossing Arm
            const armGroup = new THREE.Group();
            armGroup.position.set(0, 1.5, 0.5);
            for(let k=0; k<6; k++) {
                const seg = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: k%2===0 ? 0xffffff : 0xd50000 }));
                seg.position.x = -5 + k*2;
                armGroup.add(seg);
            }
            group.add(pole, cross1, cross2, light1, light2, armGroup);
            group.position.copy(pos);
            scene.add(group);
            obstacles.push({ mesh: group, type: 'railroad', radius: 6 });
        }

        // Helper to get track position
        const getTrackPos = (t, offset = 0) => {
            const pos = curve.getPointAt(t);
            const tangent = curve.getTangentAt(t);
            const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
            pos.add(normal.multiplyScalar(offset));
            return { pos, tangent };
        };

        function createGameElements() {
            // Materials
            const coneMat = new THREE.MeshStandardMaterial({ color: 0xff9800 });
            const rampMat = new THREE.MeshStandardMaterial({ color: 0x1565c0 });
            const oilMat = new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.9 });
            const cowMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const cowSpotMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const turboMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.6 });
            const boxMat = new THREE.MeshStandardMaterial({ map: createTextTexture('?', '#d50000', '#ffd700'), color: 0xffffff });
            const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });

            const occupied = [];
            const isSafe = (pos, r) => {
                for(const o of occupied) if(pos.distanceTo(o.pos) < (r + o.r + 10)) return false;
                return true;
            };
            const register = (pos, r) => occupied.push({ pos: pos.clone(), r: r });

            // 1. Obstacles (Cones)
            const coneGeo = new THREE.ConeGeometry(1, 3, 16);
            for (let i = 0; i < 15; i++) {
                const t = (0.1 + i * 0.06) % 1;
                const offset = (Math.random() - 0.5) * 20;
                const { pos } = getTrackPos(t, offset);
                const cone = new THREE.Mesh(coneGeo, coneMat);
                if (!isSafe(pos, 2)) continue;
                cone.position.copy(pos);
                cone.position.y = 1.5;
                cone.castShadow = true;
                scene.add(cone);
                obstacles.push({ mesh: cone, type: 'cone', radius: 1.5 });
                register(pos, 2);
            }

            // 2. Ramps (Jumps)
            const rampGeo = new THREE.BoxGeometry(6, 1, 8); // Simple wedge approximation
            for (let i = 0; i < 4; i++) {
                const t = (0.05 + i * 0.25) % 1;
                const { pos, tangent } = getTrackPos(t, 0); // Center of track
                if (!isSafe(pos, 6)) continue;
                const ramp = new THREE.Mesh(rampGeo, rampMat);
                ramp.position.copy(pos);
                ramp.position.y = 0.5;
                ramp.lookAt(pos.clone().sub(tangent));
                ramp.rotateX(-0.2); // Slope up
                scene.add(ramp);
                ramps.push({ mesh: ramp, radius: 5 });
                register(pos, 6);
            }

            // 3. Oil Slicks
            const oilGeo = new THREE.CircleGeometry(5, 32);
            for (let i = 0; i < 8; i++) {
                const t = (0.08 + i * 0.12) % 1;
                const offset = (Math.random() - 0.5) * 15;
                const { pos } = getTrackPos(t, offset);
                if (!isSafe(pos, 5)) continue;
                const oil = new THREE.Mesh(oilGeo, oilMat);
                oil.position.copy(pos);
                oil.position.y = 0.45; // Just above track
                oil.rotation.x = -Math.PI / 2;
                scene.add(oil);
                oilSlicks.push({ mesh: oil, radius: 5, active: true });
                register(pos, 5);
            }

            // 4. Moving Cows
            for (let i = 0; i < 5; i++) {
                const t = (0.2 + i * 0.18) % 1;
                const { pos, tangent } = getTrackPos(t, 0);
                
                // Better Cow Model
                const cow = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 6), cowMat);
                body.position.y = 1.5;
                body.castShadow = true;
                cow.add(body);
                
                const head = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), cowMat);
                head.position.set(0, 3, 3.5);
                head.castShadow = true;
                cow.add(head);

                const legGeo = new THREE.BoxGeometry(1, 2, 1);
                const leg1 = new THREE.Mesh(legGeo, cowSpotMat); leg1.position.set(1.5, 0, 2);
                const leg2 = new THREE.Mesh(legGeo, cowSpotMat); leg2.position.set(-1.5, 0, 2);
                const leg3 = new THREE.Mesh(legGeo, cowSpotMat); leg3.position.set(1.5, 0, -2);
                const leg4 = new THREE.Mesh(legGeo, cowSpotMat); leg4.position.set(-1.5, 0, -2);
                cow.add(leg1, leg2, leg3, leg4);

                // Horns & Nose
                const hornGeo = new THREE.ConeGeometry(0.2, 0.8, 8);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const hornL = new THREE.Mesh(hornGeo, hornMat); hornL.position.set(0.8, 4.5, 3.5); hornL.rotation.z = -0.3;
                const hornR = new THREE.Mesh(hornGeo, hornMat); hornR.position.set(-0.8, 4.5, 3.5); hornR.rotation.z = 0.3;
                const noseGeo = new THREE.BoxGeometry(2.5, 1, 0.5);
                const noseMat = new THREE.MeshStandardMaterial({ color: 0xffb7b2 });
                const nose = new THREE.Mesh(noseGeo, noseMat); nose.position.set(0, 2.5, 4.8);
                cow.add(hornL, hornR, nose);

                cow.position.copy(pos);
                cow.userData = { t: t, offset: 0, dir: 1, basePos: pos.clone(), tangent: tangent.clone() };
                scene.add(cow);
                movingCows.push(cow);
            }

            // 5. AI Cars
            const aiColors = [0x0000ff, 0x00ff00, 0xffff00];
            for(let i=0; i<3; i++) {
                const ai = createCar(aiColors[i]);

                // Assign random upgrades (up to 5 credits)
                let aiCredits = 5;
                const aiUpgrades = { speed: 0, accel: 0, handling: 0, jump: 0 };
                while (aiCredits > 0) {
                    const stat = ['speed', 'accel', 'handling', 'jump'][Math.floor(Math.random() * 4)];
                    aiUpgrades[stat]++;
                    aiCredits--;
                }
                // Start at line with player (t=0), offset sideways
                const startT = 0.0; 
                const offset = (i === 0) ? -8 : (i === 1) ? 8 : -16; // Left, Right, Far Left
                const { pos, tangent } = getTrackPos(startT, offset);
                ai.position.copy(pos);
                ai.lookAt(pos.clone().sub(tangent)); // Face forward (-Z is front)

                 // Apply base stats and random upgrades to AI cars
                const aiMaxSpeed = (80 + aiUpgrades.speed * 10) / 60;
                const aiAccel = baseStats.acceleration + (aiUpgrades.accel * 0.02);
                
                ai.userData = { t: startT, lap: 1, currentSpeed: 0, maxSpeed: aiMaxSpeed, acceleration: aiAccel, offset: offset };
                
                scene.add(ai);

                aiCars.push(ai);
            }

            // 6. Turbo Pickups
            for (let i = 0; i < 5; i++) {
                const t = (0.15 + i * 0.18) % 1;
                const { pos } = getTrackPos(t, (Math.random()-0.5)*10);
                if (!isSafe(pos, 2)) continue;
                
                const mesh = new THREE.Group();
                const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 0.5), turboMat);
                const hBar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 0.5), turboMat);
                hBar.position.y = 0.75;
                mesh.add(vBar, hBar);
                
                mesh.position.copy(pos);
                mesh.position.y = 1.5;
                scene.add(mesh);
                turbos.push({ mesh: mesh, active: true });
                register(pos, 2);
            }

            // 7. Mystery Boxes
            const boxGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            for (let i = 0; i < 12; i++) {
                const t = (0.05 + i * 0.08) % 1;
                const { pos } = getTrackPos(t, (Math.random()-0.5)*10);
                if (!isSafe(pos, 3)) continue;
                const mesh = new THREE.Mesh(boxGeo, boxMat);
                mesh.position.copy(pos);
                mesh.position.y = 1.5;
                mesh.rotation.x = Math.PI/4;
                scene.add(mesh);
                mysteryBoxes.push({ mesh: mesh, active: true });
                register(pos, 3);
            }

            // 8. Coins
            const coinGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 16);
            coinGeo.rotateX(Math.PI/2); // Face player
            for (let i = 0; i < 40; i++) {
                const t = (Math.random());
                const { pos } = getTrackPos(t, (Math.random()-0.5)*18);
                if (!isSafe(pos, 1)) continue;
                const coin = new THREE.Mesh(coinGeo, coinMat);
                coin.position.copy(pos);
                coin.position.y = 1.5;
                scene.add(coin);
                coins.push({ mesh: coin, active: true });
            }

            // 8. Buses (Slow moving obstacles)
            const busBodyGeo = new THREE.BoxGeometry(3.5, 4, 10);
            const busMat = new THREE.MeshStandardMaterial({ color: 0xFFC107 });
            const winMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            wheelGeo.rotateZ(Math.PI/2);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

            for(let i=0; i<2; i++) {
                const t = (0.5 + i * 0.4) % 1;
                const { pos, tangent } = getTrackPos(t, 6);
                if (!isSafe(pos, 6)) continue;

                const bus = new THREE.Group();
                
                // Body
                const body = new THREE.Mesh(busBodyGeo, busMat); 
                body.position.y = 2.5; 
                body.castShadow = true;
                bus.add(body);

                // Windows
                const sideWin = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1.2, 8), winMat);
                sideWin.position.set(0, 3.5, 0);
                bus.add(sideWin);
                const frontWin = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 0.1), winMat);
                frontWin.position.set(0, 3.5, -5.05);
                bus.add(frontWin);

                // Wheels
                const positions = [
                    {x: 1.8, z: 3}, {x: -1.8, z: 3},
                    {x: 1.8, z: -3}, {x: -1.8, z: -3}
                ];
                positions.forEach(p => {
                    const w = new THREE.Mesh(wheelGeo, wheelMat);
                    w.position.set(p.x, 0.6, p.z);
                    bus.add(w);
                });

                bus.position.copy(pos);
                bus.lookAt(pos.clone().sub(tangent));
                bus.userData = { t: t, speed: 0.15, offset: 6 }; // Super slow
                scene.add(bus);
                buses.push(bus);
                register(pos, 6);
            }
        }
        createGameElements();

        // --- Claw Machine Reset ---
        const clawGroup = new THREE.Group();
        const clawMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.2 });
        const rope = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 20), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        rope.position.y = 10;
        clawGroup.add(rope);
        const clawBase = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.5), clawMat);
        clawGroup.add(clawBase);
        for(let i=0; i<4; i++) {
            const prong = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), clawMat);
            const angle = (i/4) * Math.PI * 2;
            prong.position.set(Math.cos(angle)*0.8, -1, Math.sin(angle)*0.8);
            prong.rotation.y = -angle;
            prong.rotation.z = 0.2;
            clawGroup.add(prong);
        }
        clawGroup.visible = false;
        scene.add(clawGroup);

        // --- Minimap ---
        const minimapCanvas = document.getElementById('minimap');
        const mmCtx = minimapCanvas.getContext('2d');
        
        // Calculate map bounds
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        trackPathPoints.forEach(p => {
            if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
            if (p.z < minZ) minZ = p.z; if (p.z > maxZ) maxZ = p.z;
        });
        const mapScale = 180 / Math.max(maxX - minX, maxZ - minZ);
        const mapOffsetX = 100 - (minX + (maxX - minX)/2) * mapScale;
        const mapOffsetZ = 100 - (minZ + (maxZ - minZ)/2) * mapScale;

        function updateMinimap() {
            mmCtx.clearRect(0, 0, 200, 200);
            
            // Draw Track
            mmCtx.beginPath();
            mmCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            mmCtx.lineWidth = 15;
            trackPathPoints.forEach((p, i) => {
                const x = p.x * mapScale + mapOffsetX;
                const y = p.z * mapScale + mapOffsetZ;
                if (i===0) mmCtx.moveTo(x, y); else mmCtx.lineTo(x, y);
            });
            mmCtx.stroke();

            // Draw Cars
            const drawDot = (pos, color) => {
                mmCtx.fillStyle = color;
                mmCtx.beginPath();
                mmCtx.arc(pos.x * mapScale + mapOffsetX, pos.z * mapScale + mapOffsetZ, 5, 0, Math.PI*2);
                mmCtx.fill();
            };
            
            drawDot(car.position, document.getElementById('carColor').value); // Player
            aiCars.forEach(ai => drawDot(ai.position, '#' + ai.children[0].material.color.getHexString()));
        }

        // --- Physics & Controls ---
        const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false, r: false, " ": false };
        let speed = 0;
        let vy = 0; // Vertical velocity
        let isAirborne = false;
        let spinTimer = 0;
        let oilCooldown = 0;
        let rampCooldown = 0;
        let turboTimer = 0;
        let invincibleTimer = 0;
        let aiSlowTimer = 0;
        let wrongWayTimer = 0;
        let resetState = 0;
        let resetTimer = 0;
        let stickyHandTarget = null;
        let stickyHandTimer = 0;
        let stickyHandMesh = null;
        let storedItem = null;
        let pauseStartTime = 0;
        const keysPressed = {}; // Track key presses for toggle

        // Game State
        let gameState = 'menu'; // menu, countdown, racing, finished
        let laps = 1;
        const totalLaps = 3;
        let lapStartTime = 0;
        let bestLap = Infinity;
        let score = 0;
        let playerT = 0; // Track progress (0-1)
        let raceStats = { maxSpeed: 0, speedSum: 0, speedSamples: 0 };
        
        // Stats
        let currentStats = { ...baseStats };
        let friction = 0.98;

        // Menu Logic
        let credits = 5;
        const upgrades = { speed: 0, accel: 0, handling: 0, jump: 0 };

        window.adjustStat = (stat, change) => {
            if (change > 0 && credits > 0) {
                upgrades[stat]++;
                 credits--;
            } else if (change < 0 && upgrades[stat] > 0) {
                upgrades[stat]--;
                 credits++;
            }
            document.getElementById('credits').innerText = credits;
            document.getElementById('speedVal').innerText = upgrades.speed;
            document.getElementById('accelVal').innerText = upgrades.accel;
            document.getElementById('handlingVal').innerText = upgrades.handling;
            document.getElementById('jumpVal').innerText = upgrades.jump;
        };

        window.startGame = () => {
            // Apply Upgrades
            currentStats.maxSpeed = (80 + upgrades.speed * 10) / 60;
            currentStats.acceleration = baseStats.acceleration + (upgrades.accel * 0.02);
            currentStats.turnSpeed = baseStats.turnSpeed * (1 + upgrades.handling * 0.12);
            currentStats.jumpStrength = baseStats.jumpStrength + (upgrades.jump * 0.15);

            // Apply Color
            const newColor = new THREE.Color(document.getElementById('carColor').value);
            [0, 2, 3, 4].forEach(i => { // Indices of painted parts (Body, Spoiler, Legs)
                if (car.children[i]) car.children[i].material.color.set(newColor);
            });

            document.getElementById('menu').style.display = 'none';
            document.getElementById('ui-container').style.display = 'flex';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('item-hud').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('mirror-border').style.display = 'block';
            
            // Start Countdown
            gameState = 'countdown';
            const cdEl = document.getElementById('countdown');
            cdEl.style.display = 'block';
            let count = 3;
            cdEl.innerText = count;
            const timer = setInterval(() => {
                count--;
                if (count > 0) cdEl.innerText = count;
                else if (count === 0) cdEl.innerText = "GO!";
                else {
                    clearInterval(timer);
                    cdEl.style.display = 'none';
                    gameState = 'racing';
                     playerT = 0;
                    lapStartTime = Date.now();
                }
            }, 1000);
        };

        window.addEventListener('keydown', (e) => { 
            if (e.key === '=') {
                e.preventDefault();
                if (gameState === 'racing') {
                    gameState = 'paused';
                    pauseStartTime = Date.now();
                    document.getElementById('cheat-console').style.display = 'block';
                    const input = document.getElementById('cheat-input');
                    input.value = '';
                    input.focus();
                } else if (gameState === 'paused') {
                    gameState = 'racing';
                    lapStartTime += (Date.now() - pauseStartTime);
                    document.getElementById('cheat-console').style.display = 'none';
                    document.getElementById('cheat-input').blur();
                }
                return;
            }
            if(keys.hasOwnProperty(e.key)) keys[e.key] = true; 
            if(e.key.toLowerCase() === 'e') useItem();
        });
        window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });

        // Cheat Input Logic
        const cheatInput = document.getElementById('cheat-input');
        cheatInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
            if (e.key === 'Enter') {
                const code = cheatInput.value.toLowerCase().trim();
                let success = false;
                if (code === 'give invincibility') { storedItem = 'INVINCIBLE'; success = true; }
                else if (code === 'give turbo') { storedItem = 'TURBO'; success = true; }
                else if (code === 'give oil') { storedItem = 'OIL'; success = true; }
                else if (code === 'give slow ai') { storedItem = 'SLOW_AI'; success = true; }
                else if (code === 'give railroad') { storedItem = 'RAILROAD'; success = true; }
                else if (code === 'give sticky hand') { storedItem = 'STICKY_HAND'; success = true; }
                
                if (success) {
                    document.getElementById('storedItem').innerText = storedItem;
                    gameState = 'racing';
                    lapStartTime += (Date.now() - pauseStartTime);
                    document.getElementById('cheat-console').style.display = 'none';
                    cheatInput.blur();
                }
            }
        });

        function useItem() {
            if (!storedItem || gameState !== 'racing') return;
            
            if (storedItem === 'TURBO') {
                turboTimer = 120; // 2 seconds (at 60fps)
            } else if (storedItem === 'INVINCIBLE') {
                invincibleTimer = 300; // 5 seconds
            } else if (storedItem === 'OIL') {
                // Spawn oil behind
                const oilGeo = new THREE.CircleGeometry(5, 32);
                const oilMat = new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.9 });
                const oil = new THREE.Mesh(oilGeo, oilMat);
                oil.position.copy(car.position).add(car.getWorldDirection(new THREE.Vector3()).multiplyScalar(8));
                oil.position.y = 0.45;
                oil.rotation.x = -Math.PI / 2;
                scene.add(oil);
                oilSlicks.push({ mesh: oil, radius: 5 });
            } else if (storedItem === 'SLOW_AI') {
                aiSlowTimer = 300; // 5 seconds
            } else if (storedItem === 'RAILROAD') {
                // Spawn railroad sign behind
                const pos = car.position.clone().add(car.getWorldDirection(new THREE.Vector3()).multiplyScalar(12));
                createRailroadSign(pos);
            } else if (storedItem === 'STICKY_HAND') {
                // Find target (car in front)
                const allCars = [{ id: 'p', lap: laps, t: playerT, obj: car }, ...aiCars.map(ai => ({ id: 'ai', lap: ai.userData.lap, t: ai.userData.t, obj: ai }))];
                allCars.sort((a, b) => (b.lap + b.t) - (a.lap + a.t));
                const myIdx = allCars.findIndex(c => c.id === 'p');
                if (myIdx > 0) {
                    stickyHandTarget = allCars[myIdx - 1].obj;
                    stickyHandTimer = 180; // 3 seconds
                }
            }
            storedItem = null;
            document.getElementById('storedItem').innerText = "NONE";
        }

        renderer.autoClear = false;

        // Sticky Hand Visuals
        stickyHandMesh = new THREE.Group();
        const ropeGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
        ropeGeo.rotateX(-Math.PI / 2); // Align Z
        ropeGeo.translate(0, 0, 0.5); // Pivot at start, extend to +Z 1 unit
        const stickyHandMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const stickyRope = new THREE.Mesh(ropeGeo, stickyHandMat);
        stickyRope.name = 'rope';
        stickyHandMesh.add(stickyRope);
        const hand = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), stickyHandMat);
        hand.name = 'hand';
        stickyHandMesh.add(hand);
        stickyHandMesh.visible = false;
        scene.add(stickyHandMesh);

        function animate() {
            requestAnimationFrame(animate);

            if (gameState === 'menu' || gameState === 'finished' || gameState === 'paused') return;

            if (gameState === 'resetting') {
                const { tangent } = getTrackPos(playerT, 0);
                const targetLook = car.position.clone().sub(tangent);

                if (resetState === 1) { // Down
                    clawGroup.position.y -= 0.4;
                    if (clawGroup.position.y <= 3) { // Grab height
                        resetState = 2;
                        resetTimer = 0;
                    }
                } else if (resetState === 2) { // Lift & Rotate
                    if (car.position.y < 2) car.position.y += 0.1;
                    if (clawGroup.position.y < 5) clawGroup.position.y += 0.1;
                    
                    // Interpolate rotation
                    const dummy = new THREE.Object3D();
                    dummy.position.copy(car.position);
                    dummy.lookAt(targetLook);
                    car.quaternion.slerp(dummy.quaternion, 0.05);
                    clawGroup.rotation.y = car.rotation.y;

                    resetTimer++;
                    if (resetTimer > 100) {
                        resetState = 3;
                    }
                } else if (resetState === 3) { // Drop
                    if (car.position.y > 0.4) {
                        car.position.y -= 0.2;
                    } else {
                        car.position.y = 0.4;
                        resetState = 4;
                    }
                } else if (resetState === 4) { // Retract
                    clawGroup.position.y += 0.4;
                    if (clawGroup.position.y > 20) {
                        clawGroup.visible = false;
                        gameState = 'racing';
                        wrongWayTimer = 0;
                        document.getElementById('wrong-way').style.display = 'none';
                    }
                }

                camera.lookAt(car.position);
                renderer.clear();
                renderer.render(scene, camera);
                return;
            }

            const forward = keys.w || keys.ArrowUp;
            const backward = keys.s || keys.ArrowDown;
            const left = keys.a || keys.ArrowLeft;
            const right = keys.d || keys.ArrowRight;

            if (keys.r) {
                car.position.copy(startPos);
                car.position.y = 0.4;
                car.rotation.set(0, 0, 0);
                car.lookAt(2*startPos.x - startLook.x, 0.4, 2*startPos.z - startLook.z);
                vy = 0;
                speed = 0;
                spinTimer = 0;
                playerT = 0;
                turboTimer = 0;
                invincibleTimer = 0;
                aiSlowTimer = 0;
                wrongWayTimer = 0;
                storedItem = null;
                stickyHandTarget = null;
                stickyHandTimer = 0;
                stickyHandMesh.visible = false;
            }

            // --- Physics ---
            
             if (spinTimer > 0) {
                // Spin out behavior
                spinTimer--;
                car.rotation.y += 0.4; // Spin fast
                speed *= 0.9; // Slow down
                
                if (spinTimer === 0) {
                    // Reset direction to face track forward
                    const { tangent } = getTrackPos(playerT, 0);
                    car.lookAt(car.position.clone().sub(tangent));
                }
            }

            // Sticky Hand Logic
            if (stickyHandTimer > 0 && stickyHandTarget) {
                stickyHandTimer--;
                
                const start = car.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                const end = stickyHandTarget.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                const dist = start.distanceTo(end);
                
                stickyHandMesh.position.copy(start);
                stickyHandMesh.lookAt(end);
                
                const rope = stickyHandMesh.getObjectByName('rope');
                const hand = stickyHandMesh.getObjectByName('hand');
                rope.scale.z = dist;
                hand.position.z = dist;
                stickyHandMesh.visible = true;

                // Physics: Pull target back, pull player forward
                speed += 0.005; // Boost player
                if (stickyHandTarget.userData) {
                    stickyHandTarget.userData.currentSpeed -= 0.02; // Slow target
                    if (stickyHandTarget.userData.currentSpeed < 0) stickyHandTarget.userData.currentSpeed = 0;
                }

                if (stickyHandTimer === 0) {
                    stickyHandMesh.visible = false;
                    stickyHandTarget = null;
                }
            } else {
                stickyHandMesh.visible = false;
            }
            
            if (invincibleTimer > 0) {
                invincibleTimer--;
                // Rainbow Effect
                const hue = (Date.now() % 500) / 500;
                const color = new THREE.Color().setHSL(hue, 1, 0.5);
                [0, 2, 3, 4].forEach(i => { if(car.children[i]) car.children[i].material.color.copy(color); });
                
                if (invincibleTimer === 0) {
                    // Restore Color
                    const originalColor = new THREE.Color(document.getElementById('carColor').value);
                    [0, 2, 3, 4].forEach(i => { if(car.children[i]) car.children[i].material.color.copy(originalColor); });
                }
            }
            
            if (gameState === 'racing' && spinTimer === 0) {
                // Normal Driving
                let accel = currentStats.acceleration;
                let topSpeed = currentStats.maxSpeed;

                if (turboTimer > 0) {
                    accel *= 2;
                    topSpeed *= 1.5;
                    turboTimer--;
                }

                // Jump
                if (keys[" "] && !isAirborne) {
                    vy = currentStats.jumpStrength; car.position.y += 0.5; isAirborne = true;
                }

                if (forward) speed += accel;
                if (backward) speed -= accel;
                
                // Apply Max Speed Cap (Upgrade Effect)
                if (speed > topSpeed) speed = topSpeed;
                if (speed < -topSpeed * 0.5) speed = -topSpeed * 0.5;

                // Turning (only when moving and grounded-ish)
                if (Math.abs(speed) > 0.01 && !isAirborne) {
                    if (left) car.rotation.y += currentStats.turnSpeed;
                    if (right) car.rotation.y -= currentStats.turnSpeed;
                }
            }
            
            speed *= friction;

            // Stats Tracking
            if (gameState === 'racing') {
                const mph = Math.abs(speed) * 60;
                if (mph > raceStats.maxSpeed) raceStats.maxSpeed = mph;
                raceStats.speedSum += mph;
                raceStats.speedSamples++;
            }
            // Move
            car.translateZ(-speed);
            car.position.y += vy;

            // Gravity / Ground Check
            if (car.position.y > 0.4) {
                vy -= 0.025; // Gravity
                isAirborne = true;
            } else {
                car.position.y = 0.4;
                vy = 0;
                isAirborne = false;
            }

            // --- Collisions ---
            const carPos = car.position;

            // Ramps
            for (const ramp of ramps) {
                if (carPos.distanceTo(ramp.mesh.position) < ramp.radius) {
                    if (vy <= 0) { // Only jump if not already flying up
                        vy = 0.6; // Jump!
                        car.position.y += 0.5; // Lift slightly to avoid clipping
                        if (rampCooldown === 0) {
                            score += 500;
                            rampCooldown = 60;
                        }
                    }
                }
            }

            // Oil Slicks
            if (!isAirborne && spinTimer === 0 && oilCooldown === 0 && invincibleTimer === 0) {
                for (const oil of oilSlicks) {
                    if (oil.active && carPos.distanceTo(oil.mesh.position) < oil.radius - 1) {
                        spinTimer = 60; // Spin for 60 frames
                        oilCooldown = 180; // 3 seconds immunity
                        
                        // Despawn and Respawn Logic
                        oil.active = false;
                        oil.mesh.visible = false;
                        setTimeout(() => {
                            const t = Math.random();
                            const { pos } = getTrackPos(t, (Math.random()-0.5)*15);
                            oil.mesh.position.copy(pos); oil.mesh.position.y = 0.45;
                            oil.active = true; oil.mesh.visible = true;
                        }, 5000);
                    }
                }
            }

            // Obstacles & Cows
            if (invincibleTimer === 0) {
                [...obstacles, ...movingCows].forEach(obj => {
                    const pos = obj.mesh ? obj.mesh.position : obj.position;
                    const r = obj.radius || 2.5;
                    if (carPos.distanceTo(pos) < r) {
                        speed *= -0.5; // Bounce back
                    }
                });
                buses.forEach(bus => {
                    if (carPos.distanceTo(bus.position) < 4.5) speed *= -0.5;
                });
            }

            // AI Car Collision
            if (invincibleTimer === 0) aiCars.forEach(ai => {
                if (carPos.distanceTo(ai.position) < 3.5) {
                    // Simple elastic collision response
                    const dx = car.position.x - ai.position.x;
                    const dz = car.position.z - ai.position.z;
                    const angle = Math.atan2(dz, dx);
                    const push = 1.0;
                    car.position.x += Math.cos(angle) * push;
                    car.position.z += Math.sin(angle) * push;
                    speed *= 0.8; // Lose speed
                }
            });

            // Pickups
            turbos.forEach(t => {
                if (t.active) {
                    t.mesh.rotation.y += 0.05;
                    if (carPos.distanceTo(t.mesh.position) < 3) {
                        t.active = false;
                        t.mesh.visible = false;
                        turboTimer = 60; // Instant boost
                    }
                }
            });

            // Coins
            coins.forEach(c => {
                if (c.active) {
                    c.mesh.rotation.y += 0.05;
                    if (carPos.distanceTo(c.mesh.position) < 2.5) {
                        c.active = false;
                        c.mesh.visible = false;
                        score += 100;
                    }
                }
            });

            mysteryBoxes.forEach(b => {
                if (b.active) {
                    b.mesh.rotation.y += 0.02;
                    b.mesh.rotation.z += 0.02;
                    if (carPos.distanceTo(b.mesh.position) < 3) {
                        b.active = false;
                        b.mesh.visible = false;
                        const rand = Math.random();
                        storedItem = rand > 0.85 ? 'TURBO' : (rand > 0.7 ? 'OIL' : (rand > 0.55 ? 'INVINCIBLE' : (rand > 0.4 ? 'STICKY_HAND' : (rand > 0.2 ? 'SLOW_AI' : 'RAILROAD'))));
                        document.getElementById('storedItem').innerText = storedItem;
                    }
                }
            });

            if (oilCooldown > 0) oilCooldown--;
            if (rampCooldown > 0) rampCooldown--;

            // Update Moving Cows
            movingCows.forEach(cow => {
                cow.userData.offset += 0.2 * cow.userData.dir;
                if (Math.abs(cow.userData.offset) > 25) cow.userData.dir *= -1;
                
                // Move perpendicular to track tangent
                const normal = new THREE.Vector3(-cow.userData.tangent.z, 0, cow.userData.tangent.x);
                cow.position.copy(cow.userData.basePos).add(normal.multiplyScalar(cow.userData.offset));
                cow.lookAt(cow.position.clone().add(normal.multiplyScalar(cow.userData.dir)));
            });

            // Update Buses
            if (gameState === 'racing') {
                buses.forEach(bus => {
                    bus.userData.t += (bus.userData.speed / 2000);
                    if (bus.userData.t >= 1) bus.userData.t -= 1;
                    const { pos, tangent } = getTrackPos(bus.userData.t, bus.userData.offset);
                    bus.position.copy(pos);
                    bus.lookAt(pos.clone().sub(tangent));
                });
            }

            // Update AI Cars
            if (gameState === 'racing') {
                aiCars.forEach(ai => {
                    // Accelerate
                    if (ai.userData.currentSpeed < ai.userData.maxSpeed) {
                        ai.userData.currentSpeed += ai.userData.acceleration;
                    }
                    
                    let effectiveSpeed = ai.userData.currentSpeed;
                    if (aiSlowTimer > 0) effectiveSpeed *= 0.5;
                    
                    const step = effectiveSpeed / trackLength;
                    ai.userData.t += step;
                    if (ai.userData.t >= 1) { ai.userData.t -= 1; ai.userData.lap++; }
                    
                    const { pos, tangent } = getTrackPos(ai.userData.t, ai.userData.offset);
                    ai.position.copy(pos);
                    ai.position.y = 0.4;
                    ai.lookAt(pos.clone().sub(tangent)); // Fix orientation

                    // Simple AI: Avoid obstacles (very basic)
                    obstacles.forEach(obs => {
                        const dx = ai.position.x - obs.mesh.position.x;
                        const dz = ai.position.z - obs.mesh.position.z;
                        const distSq = dx*dx + dz*dz;
                         if (distSq < 40 && ai.userData.currentSpeed > 0.5) ai.userData.currentSpeed *= 0.98; // Slow down near
                    });
                });
            }

            // Track Constraint
            if (aiSlowTimer > 0) aiSlowTimer--;
            let closest = trackPathPoints[0];
            let minDst = Infinity;
            let closestIdx = 0;
            for(let i=0; i<trackPathPoints.length; i++) {
                const d = (car.position.x - trackPathPoints[i].x)**2 + (car.position.z - trackPathPoints[i].z)**2;
                if(d < minDst) {
                    minDst = d;
                    closest = trackPathPoints[i];
                    closestIdx = i;
                }
            }
            const dist = Math.sqrt(minDst);
            const limit = trackWidth - 2;
            if (dist > limit) {
                const angle = Math.atan2(car.position.z - closest.z, car.position.x - closest.x);
                car.position.x = closest.x + Math.cos(angle) * limit;
                car.position.z = closest.z + Math.sin(angle) * limit;
                speed *= 0.9;
            }

            // Wrong Way Detection
            if (gameState === 'racing') {
                const carDir = new THREE.Vector3();
                car.getWorldDirection(carDir);
                const { tangent } = getTrackPos(playerT, 0);
                // Tangent points backwards relative to movement in this setup
                if (carDir.dot(tangent) > 0 && Math.abs(speed) > 0.1) {
                    wrongWayTimer++;
                    document.getElementById('wrong-way').style.display = 'block';
                } else {
                    wrongWayTimer = 0;
                    document.getElementById('wrong-way').style.display = 'none';
                }

                if (wrongWayTimer > 600) { // 10 seconds @ 60fps
                    gameState = 'resetting';
                    resetState = 1;
                    clawGroup.position.copy(car.position);
                    clawGroup.position.y = 20;
                    clawGroup.visible = true;
                    speed = 0;
                }
            }

            // Lap Logic
            const currentT = closestIdx / trackPathPoints.length;
            // Check for lap crossing (transition from high T to low T)
            if (playerT > 0.9 && currentT < 0.1) {

                 console.log("Lap completed");
                // Lap Complete
                const now = Date.now();
                const lapTime = (now - lapStartTime) / 1000;
                if (lapTime < bestLap) bestLap = lapTime;

                
                if (laps >= totalLaps) {
                    // Race Over
                    gameState = 'finished';
                    document.getElementById('results').style.display = 'flex';
                    document.getElementById('resScore').innerText = score;
                    document.getElementById('resBest').innerText = bestLap.toFixed(2) + "s";
                    document.getElementById('resTop').innerText = Math.floor(raceStats.maxSpeed) + " MPH";
                    document.getElementById('resAvg').innerText = Math.floor(raceStats.speedSum / raceStats.speedSamples);
                } else {
                    laps++;
                    lapStartTime = now;

                }
            }
             playerT = currentT;

            // Calculate Rank
            const allCars = [{ id: 'p', lap: laps, t: playerT }, ...aiCars.map(ai => ({ id: 'ai', lap: ai.userData.lap, t: ai.userData.t }))];
            allCars.sort((a, b) => (b.lap + b.t) - (a.lap + a.t));
            const rank = allCars.findIndex(c => c.id === 'p') + 1;

            // Update HUD
            document.getElementById('rank').innerText = `${rank}/${allCars.length}`;
            document.getElementById('lapCounter').innerText = `${laps}/${totalLaps}`;
            
            updateMinimap();
            document.getElementById('lapTimer').innerText = ((Date.now() - lapStartTime) / 1000).toFixed(2);
            document.getElementById('bestLap').innerText = bestLap === Infinity ? "--:--" : bestLap.toFixed(2);
            document.getElementById('score').innerText = score;

            // Camera Chase Logic
            // Ideal position: Behind and Up relative to car
            const idealOffset = new THREE.Vector3(0, 6, 12);
            idealOffset.applyMatrix4(car.matrixWorld);
            
            camera.position.lerp(idealOffset, 0.1);
            camera.lookAt(car.position);

            // UI
            document.getElementById('speedometer').innerHTML = Math.floor(Math.abs(speed) * 60) + ' <span style="font-size: 1.5rem;">MPH</span>';

            // Render Main View
            renderer.clear();
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.render(scene, camera);

            // Render Rear View Mirror
            if (gameState === 'racing' || gameState === 'countdown') {
                const mw = 260, mh = 100;
                const mx = (window.innerWidth - mw) / 2;
                const my = window.innerHeight - mh - 20;
                renderer.setScissor(mx, my, mw, mh);
                renderer.setScissorTest(true);
                renderer.render(scene, rearCamera);
                renderer.setScissorTest(false);
            }
        }

        animate();


        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>